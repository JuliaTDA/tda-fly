---
execute:
  eval: false
---

### Persistence Homology Transform

Now we will create several filtrations based on points and lines, etc.

We start with the point (0, 0). Its filtration is the following

```{julia}
A = wings[10] |> image_to_array;
f = dist_to_point(0, 0)
Af = modify_array(A, f)
heatmap(Af)
```

with corresponding sublevel barcode as

```{julia}
point_pds = cubical_pd(Af, cutoff = 0.05)
plot_pd(point_pds)
```

or, with persistence in the y-axis:

```{julia}
plot_pd(point_pds, persistence = true)
```

Let's see step-by-step of this filtration:

```{julia}
for tr âˆˆ reverse([0:0.1:1;])
  X = findall_ids(>(tr), Af)
  title = "threshold: $tr"
  p = scatter(first.(X), last.(X), title = title)
  display(p)
end
```

Due to noise, some connected components are born in 0.2 and die only at 0. But the loops seems alright.

Let's apply this idea to all images!

```{julia}
point_rips_dc = Dict()
f = dist_to_point(0, 0)

point_rips_dc["PD"] = map(wings) do wing
  A = wing |> image_to_array;
  Af = modify_array(A, f)
  point_pds = cubical_pd(Af, cutoff = 0.05)[2]
end;

PI = PersistenceImage(point_rips_dc["PD"], size = (10, 10))
point_rips_dc["PI"] = PI.(point_rips_dc["PD"]);
```

```{julia}
final_dc = Dict();

dics = [simple_rips_dc, point_rips_dc]

final_dc["PI"] = simple_rips_dc["PI"] + point_rips_dc["PI"];
```

```{julia}
final_dc["Distance_matrix"] = pairwise_distance(final_dc["PI"]);
```

```{julia}
plot_heatmap(
  final_dc["Distance_matrix"], 
  individuals, 
  "Distance matrix for Vietoris-Rips + point-based barcodes"
)
```

What happened?! Some wing has a big distance from everything else!

```{julia}
Xs = point_rips_dc["PI"]
id = findfirst(==("c-39"), individuals)
# id = 9
X = Xs[id]
heatmap(X)
```

```{julia}
wings[id]
```

```{julia}
heatmap(wings[id])
```

The reason is that it has one small cycle right at the beggining of the filtration...